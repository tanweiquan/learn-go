【golang】map底层实现
难度：中等
参考：
 1. Golang中map底层实现方式是哈希表，map的数据被置入一个由桶组成的有序数组中，每个桶最多存放8个键值对，多出来的会被放到额外的由链表组成的溢出桶中，所以golang的map结构底层由哈希表+桶数组+溢出的桶链表组成；
 2. 哈希表有两个关键点，一个是哈希函数，第二个是解决哈希冲突：在理想情况下哈希函数能够将不同键映射到唯一的索引上，但实际情况中可能会出现不同的键映射到同个索引的情况，解决哈希冲突可以通过开放寻址法、拉链法和再散列法来处理，Golang里的map用的就是拉链法；
 3. 当装载因子超过一定量级或者哈希使用了太多的溢出桶时会发生扩容，每次扩容时会增大到原来的2倍，然后逐步将旧map的数据迁移至新map中，实现增量扩容，而删除时则只是添加删除标记，然后等待GC来完成内存的回收；

【Golang】谈一下Golang的变量逃逸问题？
参考：Golang的变量逃逸需要提到栈和堆的概念：栈一般由编译器进行管理，自动申请、分配和释放，处理的速度很快，像我们常见的函数参数这些局部变量都会放在栈上；堆适合不可预知大小的内存分配，需要提前申请，但分配的速度比较慢，且容易形成内存碎片，内存回收需要依靠垃圾回收机制。通过逃逸分析，可以尽量把哪些不用分配到堆上的变量直接分配到栈上，堆的变量少了可以减轻垃圾回收的压力，提高程序的运行速度。
编程中常见的两种逃逸场景：函数局部对象指针被返回；对象指针被多个子程序（如线程、协程）共享使用。我们可以通过go build -gcflags '-m'命令来观察变量逃逸情况。 

【Golang】谈一下Golang的垃圾回收机制？
参考：常见的垃圾回收机制有几种，如引用计数、标记清除、分代收集等，Golang语言的垃圾回收用的就是标记清除法，不过它采用的是三色标记清除：首先标记的是root根对象（全局变量、堆栈上的变量等），根对象的子对象也是存活的，在初始状态下所有的对象都是白色的。然后标记根对象为灰色，放入待处理队列。然后从待处理队列的灰色对象，将其引用的对象也标记为灰色并且加入到待处理队列中，而将刚才的灰色对象标记为黑色。然后循环这个过程，直到待处理队列为空为止，此时就剩下白色和黑色对象，然后会将白色对象清理。在标记的过程中如果存在新的引用对象，会通过写屏障直接标记为灰色。
【Golang】谈一下Golang的并发模型？（或者说谈一下Golang的Goroutine如何调度？）
【场景】
参考：
1. 在Go程序中Go语言的运行时系统（runtime）会自动帮我们创建和销毁系统级的线程（即内核线程），而对应的用户级线程（Go程）需要由我们（或者说我们编写的程序）来控制，包括线程的创建、销毁、调度、状态变更和数据处理等都需要我们自己去实现和处理。负责统筹调配Go并发编程模型有三个主要元素：G（gorouteine）、M（machine，代表的是系统级线程）和P（处理器processor，用于维护gorouteine队列），它们的关系可以简单地理解为P可以承载若干了G，然后是这些G适时适当地与M进行对接，起到一个中介的作用。GMP模型对多线程M:N模型的实现（如果运行的G阻塞时，系统会创建新的M并进行处理），本质上就是多个用户态线程被绑定到多个内核线程上，线程的上下文切换发生在用户空间，而多个内核线程又可以充分利用多核处理器资源。
2. 在多线程里线程之间的大多通过共享内存来通信，这就会涉及到资源抢占、一致性问题，从而引入多线程锁、原子操作等问题，所以Golang里使用了基于消息传递来处理并发问题的的CSP模型，里面最重要的角色就是channel，channel并发安全的，它保证同一时间只有一个活跃的线程能够访问数据，能够从设计上天然地避免线程竞争和数据冲突的问题，同时消息传递在解耦方面与共享内存相比也有一定优势，我们可以将线程的职责分成生产者和消费者，并通过消息传递的方式将它们解耦，不需要再依赖共享内存；

【Golang】谈一下Golang里有哪些锁？
参考：互斥锁sync.Mutex、读写锁sync.RWMutex、sync.Map安全锁；

【Golang】谈一下Golang中如何实现并发？
参考：
1. 通过goroutine和channel实现并发控制；（CSP模型是生产者-消费者模型：创建一个通道，一个协程在往通道里写数据，另一个协程在从通道里读出数据）
2. 通过sync包的WaitGroup实现并发控制；

【Golang】slice底层实现
参考：
切片即动态数组，可以动态扩容改变数组的容量. golang 的 slice 底层结构如下所示，
type slice struct {
    array unsafe.Pointer // 指向数组的指针
    len   int // 切片中元素的数量
    cap   int // array 数组的总容量
}
它是一个结构体，里面包含了指向数组的地址，并通过 len、cap 保存数组的元素数、容量


【Golang】slice如何扩充
原理：当使用 append(slice,data) 时候，Golang 会检查底层的数组的长度是否已经不够，如果长度不够，Golang 则会新建一个数组，把原数组的数据拷贝过去，再将 slice 中的指向数组的指针指向新的数组。
扩容规则：
如果 oldCap(扩容前容量)*2 < cap(最小所需容量) --> newCap=cap
否则
     oldlen(扩容前元素个数) < 1024 --> newCap=oldCap*2
     oldlen(扩容前元素个数) > 1024 --> newCap=oldCap*1.25
总结：
如果扩容最小所需空间比扩容前的两倍空间还要大，则扩容后的空间就是扩容所需最小空间。
否则，如果扩容最小所需空间比扩容前的两倍空间要小：
如果扩容前的元素个数小于1024，则取扩容前2倍的容量
如果扩容前的元素个数大于1024，则取扩容前1.25倍的容量

口诀：所需最小大于原容两倍取所需，所需小于两倍原容分情况，原容元素个数小于1024取2倍原容，原容元素个数大于1024取1.25倍原容

【Golang】channel底层实现
创建channel实际上就是在内存中实例化了一个hchan的结构体，并返回一个ch指针，我们使用过程中channel在函数之间的传递都是用的这个指针。这就是为什么函数传递中无需使用channel的指针，而直接用channel就行了，因为channel本身就是一个指针。channel中有个缓存buf，是用来缓存数据的，通过缓存buf，channel实现了队列。

【Golang】goroutine底层如何运行
每一个goroutine是一个独立的执行单元，相较于每个OS线程固定分配2M内存的模式，goroutine的栈采取了动态扩容方式， 初始时仅为2KB，随着任务执行按需增长，最大可达1GB，且完全由golang自己的调度器 Go Scheduler 来调度。此外，GC还会周期性地将不再使用的内存回收，收缩栈空间

【Golang】如何发生panic后程序如何执行&如何捕捉错误
使用defer和recover来捕捉错误，注意一点的是，在使用defer时，要将defer语句放在发生panic前。
如：
defer func(){
             err:=recover()
}
panic("error is happening")