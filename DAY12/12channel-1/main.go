package main

import (
	"fmt"
)

//当通道chan发送数据给其他变量后，chan里就不保存数据了，想让chan再发送数据给变量，则需要再发送数据给chan
/* 1.缓冲区大小不同
不带缓冲区的chan的缓冲区大小是0，带缓冲区的chan缓冲区至少是1,缓冲区设置多少就是可以传多少次值进去通道
2.运行方式不同
不带缓冲区的chan线程写入时会立马发生阻塞，直到有其他线程有对该chan执行接收操作且接收成功后，写入的进程才会解除阻塞。
不带缓冲区的chan线程接收时也会立马发生阻塞，直到有其他线程对该chan执行写入操作后，接收的线程才会解除阻塞。*/

/* 带缓冲区的channel:
写入阻塞条件:缓冲区满
取出阻塞条件：缓冲区没有数据

不带缓冲区的channel:
写入阻塞条件:同一时间没有另外一个线程对该chan进行读操作
取出阻塞条件:同一时间没有另外一个线程对该chan进行取操作 */
func recv(c chan int) {
	ret1 := <-c
	fmt.Println("接收成功", ret1)
}

func main() {
	//无缓冲的通道
	//无缓冲的通道只有在有人接收值的时候才能发送值。
	//就像你住的小区没有快递柜和代收点，快递员给你打电话必须要把这个物品送到你的手中，简单来说就是无缓冲的通道必须有接收才能发送。
	//使用无缓冲通道进行通信将导致发送和接收的goroutine同步化。因此，无缓冲通道也被称为同步通道。

	// 无缓冲的通道又称为阻塞的通道。我们来看一下下面的代码：
	// ch1 := make(chan int)
	// ch1 <- 10
	// fmt.Println("发送成功")

	//启用一个goroutine去接收值
	ch2 := make(chan int)
	go recv(ch2) // 启用goroutine从通道接收值
	ch2 <- 10
	fmt.Println("ch2发送成功")
	//有缓冲的通道，无变量接收值
	ch3 := make(chan int, 1) // 创建一个容量为1的有缓冲区通道
	ch3 <- 10
	fmt.Println("ch3发送成功")

	//.....................下面是重点..........................
	//有缓冲的通道，且有变量接收值
	ch4 := make(chan int, 1) // 创建一个容量为1的有缓冲区通道
	ch4 <- 10
	ret3 := <-ch3
	fmt.Println("ch4发送成功,ret3接收成功", ret3)
}
