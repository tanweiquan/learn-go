package main

import "fmt"

//channel
/*不带缓冲区的channel:
写入阻塞条件:同一时间没有另外一个线程对该chan进行读操作
取出阻塞条件:同一时间没有另外一个线程对该chan进行取操作 */

/*带缓冲区的channel:
写入阻塞条件:缓冲区满
取出阻塞条件：缓冲区没有数据*/

func main() {
	//情况一，当通道缓冲区满了，还继续往通道传值时，会发生阻塞，通道会等待接收者把变量全部取完
	ch1 := make(chan int, 1)
	ch1 <- 100 //传100进通道，可以
	ch1 <- 100 //再传100进通道，不行，因为通道缓冲区满了，因此发生了阻塞,必须要先把值接收了以后才能继续传值
	x := <-ch1
	fmt.Println(x)
	//情况二，当通道中没有值还继续让通道传值时，会发生阻塞，一直等待有值传进通道为止
	//例如ch2要每秒接收一个数据，但发送方每5秒才发送一个数据，这样就会有通道空了还再请求接收通道数据的情况
	ch2 := make(chan int, 1)
	ch2 <- 100
	<-ch2      //这里将100从通道取出来了，因此通道中没有值
	y := <-ch2 //这里继续从通道中取值，因为通道中没有值，因此会发生阻塞，等待值传进来（会一直等）
	fmt.Println(y)
}

//除非关闭通道，不然通道是会一直等待下去的
