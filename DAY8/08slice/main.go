package main

import (
	"fmt"
	"sort"
)

//切片slice
//数组是[数字]T或者[...]T;而切片是[]T
//切片是简化版动态数组，因为动态数组的长度不固定，因此切片的长度不能作为切片类型的组成部分
//声明切片的基本语法：var name []T(其中T是切片中元素的类型)
func main() {
	//声明切片类型
	var a []string              //声明一个字符串切片
	var b = []int{}             //声明一个整型切片并初始化
	var c = []bool{true, false} //声明一个布尔值切片并初始化
	var d = []bool{false, true} //声明一个布尔值切片并初始化
	fmt.Println(b)
	fmt.Println(a)
	fmt.Println(c)
	fmt.Println(a == nil)
	fmt.Println(b == nil)
	fmt.Println(c == nil)
	//fmt.Println(c == d) 切片是引用类型，不支持直接比较，只能和nil比较
	fmt.Println(d)
	//切片拥有自己的长度和容量，可以通过内置的len()函数求长度，使用cap()函数求容量
	//基于数组定义切片
	a1 := [6]int{55, 56, 57, 58, 59, 60}
	b1 := a1[1:4] //[56,57,58],即位置[1,4)里的元素，注意右边的数字是不包含的。左闭右开
	fmt.Println(a1)
	fmt.Println(b1)
	//注意这里涉及到指针问题
	//切片的长度为切片指针位置开始到指定位置之间的元素的数量，切片的容量为指针位置到底层数组最后元素的元素数量
	fmt.Printf("b1的长度=%d b1的容量=%d\n", len(b1), cap(b1)) //b1长度为3，b1容量为5
	/*其中还支持以下表示方式
	h:=a1[:4] 位置为[0，4)的元素,长度为[0,4)里的元素个数，位置为0到3，共三个，即长度为4，指针位置为0开始，所以容量为6
	i:=a1[1:] 位置为[1,6]的元素
	j:=a1[:] 位置为[0,6]的元素
	*/
	//切片再切片
	c1 := b1[1:2]
	fmt.Println(c1) //再次切片后切片的指针指向切片里的元素57，即指向底层数组的57，则从底层元素57开始算，容量为4
	fmt.Printf("c1的长度=%d c1的容量=%d\n", len(c1), cap(c1))
	//使用make()函数创造切片,相当于框住了自定义的内存,创建了数组
	s1 := make([]int, 6, 7) //表达式为name:=make([]T,长度，容量)
	fmt.Printf("s1的长度=%d s1的容量=%d\n", len(s1), cap(s1))
	fmt.Println(s1) //[0 0 0 0 0 0]，未初始化的切片
	s2 := make([]int, 0, 5)
	fmt.Printf("s2的长度=%d s2的容量=%d\n", len(s2), cap(s2))
	fmt.Println(s2) //[]，没有元素的切片为空切片，用len()==nil来判断
	//切片的赋值拷贝
	s3 := make([]int, 3)
	fmt.Println(s3)
	s4 := s3    //s3和s4都指向了同一个底层数组
	s4[0] = 144 //给切片赋值，实际给底层数组的元素赋值
	fmt.Println(s3)
	fmt.Println(s4)
	//切片的遍历
	//1、根据索引遍历
	for i := 0; i < len(s3); i++ {
		fmt.Println(s3[i])
	}
	//2、for range循环遍历
	for i, v := range s3 {
		fmt.Println(i, v)
	}
	//使用append()函数来给切片追加元素,表达式：name = append(name,追加的元素)
	s5 := []string{"北京", "上海", "广州"}
	//s5[3] = "深圳" //(注意[3]表示位置为4),而追加位置为4的字符串"深圳”，会编译错误：索引越界
	//fmt.Println(s5)
	//调用append()追加元素时，要用原来的切片变量接收返回值
	//append()追加元素时，当底层数组放不下时，go底层会把底层数组换一个，相当于把开辟新内存
	s5 = append(s5, "深圳")
	fmt.Println(s5) //[北京 上海 广州 深圳]
	/*append()开辟新内存后：
	1、当新申请的cap>2倍旧cap，最终容量=新容量；
	2、否则判断，当旧cap<1024，最终容量=2旧cap；
	3、当旧cap>=1024,则最终容量从旧cap开始循环增加旧cap1/4，直到最终cap>=新申请的cap
	4、当最终容量计算值溢出，则最终容量就是新申请的容量
	*/
	//(这里的新申请cap为4，而旧cap=4,新申请cap小于2倍旧cap，也小于1024，则最终容量就是2x3=6)
	fmt.Printf("s5的长度=%d s5的容量=%d\n", len(s5), cap(s5)) //长度是4，容量是6
	s6 := []string{"重庆", "成都", "长沙"}
	s5 = append(s5, s6...) //...表示把数组拆开，如s6...表示把字符串组拆开成字符串:"重庆","成都"，"长沙"
	fmt.Println(s5)
	fmt.Printf("s5的长度=%d s5的容量=%d\n", len(s5), cap(s5))
	//使用copy复制切片，表达式：copy(name,被复制的数组)
	d1 := []int{1, 2, 3, 4, 5, 6}
	d2 := d1
	var d3 = make([]int, 6)
	copy(d3, d1)            //将d1里的元素copy到d3里
	fmt.Println(d1, d2, d3) //这里全部都是[1 2 3 4 5 6]
	d1[0] = 100
	fmt.Println(d1, d2, d3) //这里d1和d2是[100 2 3 4 5 6]，d3仍是[1 2 3 4 5 6]
	//go中没有删除数组元素的函数，但可以通过其他方法删除数组元素
	//将d1中的索引为0和3的元素删掉
	d1 = append(d1[1:3], d1[4:]...)
	fmt.Println(d1) //[2 3 5 6]
	//d1的指针指向底层数组，容量从指针指向的第一个元素算到最后一个元素
	fmt.Println(cap(d1))                   //5,d1指向索引为1的元素2，从索引1到索引6，容量为5
	x1 := [...]int{1, 2, 3, 4, 5, 6, 7, 8} //数组，注意[...]才是数组，[]是切片
	x2 := x1[:]                            //切片[1 2 3 4 5 6 7 8]
	fmt.Println(x2, len(x2), cap(x2))      //长度是8，容量是8
	x2 = append(x2[1:2], x2[3:5]...)       //[2 4 5],修改了底层数组*
	fmt.Println(x2, len(x2), cap(x2))      //长度是3，容量是7
	//很重要的知识点
	/*当切片使用append()函数删掉数组中的一个元素时
	相当于底层数组位置数目不变，将切片的值从切片指针指向的第一个元素开始放回数组中*/
	//下面的x1相当于x1[1]=2,x1[2]=4,x1[3]=5,其他元素如索引为0的1，索引为4-7的元素5、6、7、8按原来位置放，不变
	fmt.Println(x1, len(x1), cap(x1)) //[1 2 4 5 5 6 7 8],长度是8，容量也是8
	//1、切片不保存具体的值
	//2、切片对应一个底层数组
	//3、底层数组都是占用一块连续的内存
	//4、修改数组里的元素：x2=append(x2[:1],x2[2:]...)和x2[0]=100
	fmt.Printf("%p\n", &x2[0]) //0xc000142108(对应索引为0的内存地址)
	fmt.Printf("%p\n", &x2[1]) //0xc000142110（对应索引为1的内存地址）
	fmt.Printf("%p\n", &x2)    //0xc000114228（数组的内存地址）
	//x2[0] = 100                //修改了底层数组，里面的元素以及整个底层数组对应的内存地址也发生改变
	//fmt.Println(x2)            //[100 3 4 5]
	//fmt.Printf("%p\n", &x2[0]) //0xc00000c510
	//fmt.Printf("%p\n", &x2[1]) //0xc00000c518
	//fmt.Printf("%p\n", &x2)    //0xc000004240
	//练习
	var h = make([]int, 5, 10) //创建切片[0 0 0 0 0]
	fmt.Println(h)
	//1、用for追加元素
	for i := 0; i < 9; i++ { //[0 0 0 0 0 0 1 2 3 4 5 6 7 8]；即在定义的元素长度以后追加0-8的元素
		h = append(h, i)
	}
	fmt.Println(h)
	fmt.Printf("h容量=%d\n", cap(h)) //20；新申请的容量cap:9，小于2倍的旧容量:2*10;最终容量为2倍的旧容量20
	//2、切片的排序
	var h1 = []int{1, 6, 9, 2, 3, 8}
	sort.Ints(h1[:]) //对切片里的元素进行排序
	fmt.Println(h1)  //[1 2 3 6 8 9]
}
